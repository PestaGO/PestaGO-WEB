# -*- coding: utf-8 -*-
"""mangosteen_lead_disease_detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CG_tidrwRcKPyoaSlJx2bJLs-iHN1e7I
"""

!pip install ultralytics roboflow

import os
import glob
import json
import random
import tempfile
import time
import argparse
import cv2
import numpy as np
import yaml
import matplotlib.pyplot as plt
import seaborn as sns
from IPython.display import Image, display
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
from ultralytics import YOLO
from roboflow import Roboflow
from google.colab import files

# Constants
CONFIDENCE_THRESHOLD = 0.6
IOU_THRESHOLD = 0.5
MAX_DETECTIONS = 50
IMAGE_SIZE = 640
BATCH_SIZE = 16
NUM_EPOCHS = 50
CLASSES = ['Healthy', 'Infected Leaf', 'Disease Part']
COLORS = {
    'Healthy': (0, 255, 0),      # Green
    'Infected Leaf': (255, 165, 0),  # Orange
    'Disease Part': (255, 0, 0)   # Red
}

class MangosteenDiseaseDetector:
    def __init__(self):
        """Initialize the disease detector with model and dataset configuration."""
        self.model = None
        self.setup_dataset()

    def setup_dataset(self):
        """Download and configure the dataset from Roboflow."""
        rf = Roboflow(api_key="XISY5ydW3CGX9FA7Mwzr")
        project = rf.workspace("janodin-patundog").project("mangosteen-leaf-disease")
        version = project.version(2)
        self.dataset = version.download("yolov8")
        print("Dataset downloaded and configured successfully!")

    def train_model(self):
        """Train the YOLOv8 model with optimized parameters."""
        # Initialize model
        self.model = YOLO('yolov8n.pt')

        # Train with optimized parameters
        results = self.model.train(
            data='/content/Mangosteen-Leaf-Disease-2/data.yaml',
            epochs=NUM_EPOCHS,
            imgsz=IMAGE_SIZE,
            batch=BATCH_SIZE,
            name='mangosteen_disease_model',
            # patience=5,  # Early stopping patience
            device='0',  # Use GPU if available
            pretrained=True,
            amp=True,  # Automatic Mixed Precision
            augment=True,  # Use built-in augmentations
            mixup=0.1,  # Apply mixup augmentation
            mosaic=0.5,  # Apply mosaic augmentation
            degrees=10.0,  # Random rotation augmentation
            translate=0.2,  # Random translation augmentation
            scale=0.5,  # Random scaling augmentation
            fliplr=0.5,  # Horizontal flip probability
            flipud=0.0,  # Vertical flip probability (disabled)
            hsv_h=0.015,  # HSV-Hue augmentation
            hsv_s=0.7,  # HSV-Saturation augmentation
            hsv_v=0.4,  # HSV-Value augmentation
            warmup_epochs=3,  # Gradual warmup
            optimizer='AdamW',  # Using AdamW optimizer
            lr0=0.001,  # Initial learning rate
            lrf=0.01,  # Final learning rate factor
            momentum=0.937,
            weight_decay=0.0005,
            box=7.5,  # Box loss gain
            cls=0.5,  # Class loss gain
            dfl=1.5,  # DFL loss gain
            close_mosaic=10,  # Close mosaic augmentation for last N epochs
            overlap_mask=True,  # Overlapping masks
            mask_ratio=4,  # Mask downsample ratio
            single_cls=False,  # Multi-class detection
            val=True,  # Run validation
            plots=True,  # Generate plots
            save=True,  # Save model
            save_period=10  # Save checkpoint every N epochs
        )
        return results

    def load_best_weights(self):
        """Find and load the best weights from training."""
        print("\nSearching for model weights...")
        weight_files = glob.glob('runs/detect/mangosteen_disease_model*/weights/best.pt')

        if not weight_files:
            alternative_paths = ['model_weights/best.pt', 'weights/best.pt', 'best.pt']
            for path in alternative_paths:
                if os.path.exists(path):
                    weight_files.append(path)
                    break

        if not weight_files:
            raise FileNotFoundError("No weights file found! Please train the model first.")

        best_weights_path = max(weight_files, key=os.path.getmtime)
        self.model = YOLO(best_weights_path)
        return best_weights_path

    def evaluate_model(self, test_path):
        """Evaluate model performance on test set."""
        metrics = self.model.val(
            data='/content/Mangosteen-Leaf-Disease-2/data.yaml',
            split='test',
            conf=CONFIDENCE_THRESHOLD,
            iou=IOU_THRESHOLD,
            max_det=MAX_DETECTIONS,
            verbose=True
        )

        # Print metrics
        print("\nModel Performance Metrics:")
        print(f"mAP50: {metrics.box.map50:.3f}")
        print(f"mAP50-95: {metrics.box.map:.3f}")

        # Convert numpy arrays to float for proper formatting
        precision = float(metrics.box.p.mean()) if hasattr(metrics.box.p, 'mean') else metrics.box.p
        recall = float(metrics.box.r.mean()) if hasattr(metrics.box.r, 'mean') else metrics.box.r

        print(f"Precision: {precision:.3f}")
        print(f"Recall: {recall:.3f}")

    def plot_confusion_matrix(self, data_path='/content/Mangosteen-Leaf-Disease-2/test/images'):
        """Generate and plot confusion matrix from test predictions."""
        y_true = []
        y_pred = []

        test_images = [os.path.join(data_path, f) for f in os.listdir(data_path)
                      if f.endswith(('.jpg', '.jpeg', '.png'))]

        for img_path in test_images:
            true_label = 'Infected' if 'infected' in img_path.lower() else 'Healthy'
            y_true.append(true_label)

            results = self.model.predict(img_path, conf=CONFIDENCE_THRESHOLD, verbose=False)[0]

            # Determine prediction
            if len(results.boxes) == 0:
                pred_label = 'Healthy'
            else:
                has_infection = any(results.names[int(box.cls[0])] in ['Infected Leaf', 'Disease Part']
                                for box in results.boxes)
                pred_label = 'Infected' if has_infection else 'Healthy'
            y_pred.append(pred_label)

        # Plot confusion matrix
        classes = ['Healthy', 'Infected']
        cm = confusion_matrix(y_true, y_pred, labels=classes)

        fig, ax = plt.subplots(figsize=(8, 6))
        disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=classes)
        disp.plot(ax=ax, cmap='Blues', values_format='d')
        plt.title('Confusion Matrix')

        plt.savefig('confusion_matrix.jpg', bbox_inches='tight', dpi=300)
        plt.close(fig)
        display(Image('confusion_matrix.jpg'))

    def predict_single_image(self, image_path):
        """Make predictions on a single image."""
        img = cv2.imread(image_path)
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

        predictions = self.model.predict(
            source=image_path,
            conf=CONFIDENCE_THRESHOLD,
            iou=IOU_THRESHOLD,
            max_det=MAX_DETECTIONS,
            agnostic_nms=True,
            verbose=False
        )[0]

        """Process predictions."""
        results = {cls: {'count': 0, 'confidences': []} for cls in CLASSES}

        # First, collect all Disease Part boxes
        disease_part_boxes = []
        for box in predictions.boxes:
            cls = int(box.cls[0].cpu().numpy())
            class_name = predictions.names[cls]
            if class_name == 'Disease Part':
                x1, y1, x2, y2 = box.xyxy[0].cpu().numpy()
                disease_part_boxes.append((x1, y1, x2, y2))

        # Then, collect all Infected Leaf boxes and filter them
        valid_infected_leaf_boxes = []
        for box in predictions.boxes:
            cls = int(box.cls[0].cpu().numpy())
            class_name = predictions.names[cls]
            if class_name == 'Infected Leaf':
                x1, y1, x2, y2 = box.xyxy[0].cpu().numpy()
                # Check if this infected leaf contains any disease parts
                has_disease_part = False
                for d_x1, d_y1, d_x2, d_y2 in disease_part_boxes:
                    # Check if disease part box center is inside this infected leaf box
                    disease_center_x = (d_x1 + d_x2) / 2
                    disease_center_y = (d_y1 + d_y2) / 2
                    if (x1 <= disease_center_x <= x2 and y1 <= disease_center_y <= y2):
                        has_disease_part = True
                        break
                if has_disease_part:
                    valid_infected_leaf_boxes.append((x1, y1, x2, y2))

        # Process all detections
        for box in predictions.boxes:
            cls = int(box.cls[0].cpu().numpy())
            conf = float(box.conf[0].cpu().numpy())
            class_name = predictions.names[cls]

            # Apply stricter confidence threshold (0.6) to filter out low-confidence detections
            if conf < CONFIDENCE_THRESHOLD:
                continue

            x1, y1, x2, y2 = box.xyxy[0].cpu().numpy()

            # Skip Infected Leaf detections that don't contain Disease Parts
            if class_name == 'Infected Leaf':
                box_coords = (x1, y1, x2, y2)
                if box_coords not in valid_infected_leaf_boxes:
                    continue

            # Skip Disease Part detections that are not inside any valid Infected Leaf
            if class_name == 'Disease Part':
                is_inside_infected = False
                for leaf_x1, leaf_y1, leaf_x2, leaf_y2 in valid_infected_leaf_boxes:
                    # Check if disease part box center is inside infected leaf box
                    disease_center_x = (x1 + x2) / 2
                    disease_center_y = (y1 + y2) / 2
                    if (leaf_x1 <= disease_center_x <= leaf_x2 and
                        leaf_y1 <= disease_center_y <= leaf_y2):
                        is_inside_infected = True
                        break
                if not is_inside_infected:
                    continue

            if class_name in results:
                results[class_name]['count'] += 1
                results[class_name]['confidences'].append(conf)

                """Draw bounding box and label on image."""
                cv2.rectangle(img,
                            (int(x1), int(y1)),
                            (int(x2), int(y2)),
                            COLORS[class_name],
                            2)

                label = f'{class_name} {conf:.2%}'
                cv2.putText(img,
                        label,
                        (int(x1), int(y1)-10),
                        cv2.FONT_HERSHEY_SIMPLEX,
                        0.5,
                        COLORS[class_name],
                        2)

        return img, results

    def visualize_test_images(self, test_path='/content/Mangosteen-Leaf-Disease-2/test/images', num_images=9):
        """Visualize predictions on test images in a grid.

        Args:
            test_path: Path to test images directory
            num_images: Number of random images to visualize (max 9)
        """
        # Get list of test images
        test_images = [f for f in os.listdir(test_path) if f.endswith(('.jpg', '.jpeg', '.png'))]

        if not test_images:
            print("\nNo test images found!")
            return

        print(f"\nMaking predictions on {min(num_images, len(test_images))} test images...")

        # Get random images
        num_images = min(num_images, len(test_images))
        selected_images = random.sample(test_images, num_images)

        # Process each image
        results = []
        for img_name in selected_images:
            img_path = os.path.join(test_path, img_name)
            img, predictions = self.predict_single_image(img_path)
            results.append((img, predictions, img_name))

        """Plot prediction results in a grid."""
        rows = (len(results) + 2) // 3
        cols = 3

        # Create figure and axes grid with reduced height
        fig, axes = plt.subplots(rows, cols, figsize=(20, 6*rows))
        axes = axes.ravel()  # Flatten axes array for easier indexing

        # Display each result
        for idx, (img, predictions, _) in enumerate(results):
            ax = axes[idx]
            ax.imshow(img)
            ax.axis('off')

            # Create simple title with predictions
            title_parts = []
            for class_name, data in predictions.items():
                if data['count'] > 0:
                    avg_conf = sum(data['confidences']) / data['count']
                    title_parts.append(f"{class_name}: {data['count']} ({avg_conf:.1%})")

            ax.set_title('\n'.join(title_parts), pad=10)

        # Hide any unused subplots
        for idx in range(len(results), len(axes)):
            axes[idx].axis('off')

        # Save figure
        plt.savefig('prediction_grid.jpg', dpi=300, bbox_inches='tight')
        plt.close()
        display(Image('prediction_grid.jpg'))

    def process_uploaded_image(self):
        """Process a single uploaded image and display results."""
        try:
            print("\nWaiting for image upload...")
            uploaded = files.upload()

            if not uploaded:
                print("No file was uploaded.")
                return

            if len(uploaded) > 1:
                print("Please upload only one image at a time.")
                return

            # Process the uploaded file
            filename = list(uploaded.keys())[0]
            content = uploaded[filename]

            # Save to temporary file
            with tempfile.NamedTemporaryFile(suffix=os.path.splitext(filename)[1], delete=False) as temp_file:
                temp_file.write(content)
                temp_path = temp_file.name

            try:
                # Make prediction
                print(f"\nAnalyzing image: {filename}")
                img, predictions = self.predict_single_image(temp_path)

                # Display results
                plt.figure(figsize=(12, 8))
                plt.imshow(img)
                plt.axis('off')

                # Save and display
                plt.savefig('uploaded_prediction.jpg', bbox_inches='tight', dpi=300)
                plt.close()
                display(Image('uploaded_prediction.jpg'))

            finally:
                # Clean up temporary file
                os.unlink(temp_path)

        except Exception as e:
            print(f"An error occurred: {str(e)}")
            print("Please make sure you uploaded a valid image file.")

def setup_detector():
    """Initialize and return a detector instance."""
    detector = MangosteenDiseaseDetector()
    return detector

def train_detector(detector):
    """Train the model."""
    print("\nStarting model training...")
    detector.train_model()
    print("\nTraining completed!")

def evaluate_detector(detector):
    """Evaluate model performance."""
    detector.load_best_weights()
    print("\nEvaluating model...")
    detector.evaluate_model('/content/Mangosteen-Leaf-Disease-2/test/images')
    detector.plot_confusion_matrix()

def show_test_images(detector):
    """Show predictions on test images."""
    detector.load_best_weights()
    detector.visualize_test_images()

def test_your_image(detector):
    """Test with your own image."""
    detector.load_best_weights()
    detector.process_uploaded_image()

# Example usage in Colab:
"""
# First cell: Setup
detector = setup_detector()

# Second cell: Train
train_detector(detector)

# Third cell: Evaluate
evaluate_detector(detector)

# Fourth cell: View test images
show_test_images(detector)

# Fifth cell: Test your own image
test_your_image(detector)
"""

# First cell: Setup
detector = setup_detector()

# Second cell: Train
train_detector(detector)

# Third cell: Evaluate
evaluate_detector(detector)

# Fourth cell: View test images
show_test_images(detector)

# Fifth cell: Test your own image
test_your_image(detector)